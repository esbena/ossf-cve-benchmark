/**
 * This is the codeql driver for the CVE Benchmarker.
 * See ../README.md for how to use this driver.
 */

import * as fs from "fs-extra";
import * as path from "path";
import * as sarif from "sarif";
import * as cp from "child_process";
import {
  AnalyzeParams,
  drive,
  execFileSyncWithImprovedExceptionMessage,
  getDriverCommandlineInputs,
  GetPath,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  Dir,
  EnvironmentSpecification,
  File,
  Instructions,
  CommitID
} from "../../../../src/persistent-types";
import { readJSONFile } from "../../../../src/util";

type LocationID = number;
type AlternativeAlertLocationMapping = Record<RuleID, LocationID[]>;
type RuleID = string;
type CodeQLMetaData = {
  kind: string;
  precision: string;
  id: string;
  tags: string;
};

/**
 * Cache for `getMetaData/2`
 */
const metadataCache: Map<File, CodeQLMetaData> = new Map();
/**
 * @returns the codeql metadata for `query`.
 */
function getMetaData(query: File, codeql: File): CodeQLMetaData {
  if (!metadataCache.has(query)) {
    metadataCache.set(
      query,
      JSON.parse(
        execFileSyncWithImprovedExceptionMessage(codeql, [
          "resolve",
          "metadata",
          "--format",
          "json",
          query
        ]).toString()
      )
    );
  }
  return metadataCache.get(query);
}

/**
 * @returns true iff file `query` has `@id <queryId>`.
 */
function hasQueryID(query: File, queryId: RuleID, codeql: File) {
  if (
    !query.endsWith(".ql") ||
    // huge performance improvement over running codeql on all ql files
    !fs.readFileSync(query, "utf8").includes(queryId)
  ) {
    return false;
  }
  let meta = getMetaData(query, codeql);
  return meta.id === queryId;
}

/**
 * @returns true iff file `query` has `@tags external/cwe/cwe-<cweNumber>`.
 */
function queryHasCweNumber(query: File, cweNumber: number, codeql: File) {
  if (!query.endsWith(".ql")) {
    return false;
  }

  let content = fs.readFileSync(query, "utf8");
  if (
    // huge performance improvement over running codeql on all ql files
    !["", "0", "00"].some(prefix =>
      content.includes(`external/cwe/cwe-${prefix}${cweNumber}`)
    )
  ) {
    return false;
  }
  let meta = getMetaData(query, codeql);
  return meta.tags.split(" ").some((tag: string) => {
    let match = /external\/cwe\/cwe-(\d+)/.exec(tag);
    return match && +match[1] === cweNumber;
  });
}

/**
 * Searches a directory structure recursively for a query file with a specific id.
 *
 * @returns the query file with the given id.
 */
function getQueryFileByID(queryId: RuleID, dir: Dir, codeql: File): File[] {
  const dirents = fs.readdirSync(dir, { withFileTypes: true });
  const files: File[] = dirents.flatMap((dirent: fs.Dirent): File[] => {
    if (dirent.isSymbolicLink() || dirent.name.startsWith(".")) {
      return [];
    }
    const res = path.resolve(dir, dirent.name);
    if (dirent.isDirectory()) {
      return getQueryFileByID(queryId, res, codeql);
    }
    if (hasQueryID(res, queryId, codeql)) {
      return [res];
    }
    return [];
  });
  return files;
}

/**
 * Searches a directory structure recursively for a query file with a specific CWE number.
 *
 * @returns the query files with the given CWE.
 */
function getQueryFilesByCWENumber(
  cweNumber: number,
  dir: Dir,
  codeql: File
): File[] {
  const dirents = fs.readdirSync(dir, { withFileTypes: true });
  const files: File[] = dirents.flatMap((dirent: fs.Dirent): File[] => {
    if (dirent.isSymbolicLink() || dirent.name.startsWith(".")) {
      return [];
    }
    const res = path.resolve(dir, dirent.name);
    if (dirent.isDirectory()) {
      return getQueryFilesByCWENumber(cweNumber, res, codeql);
    }
    if (queryHasCweNumber(res, cweNumber, codeql)) {
      return [res];
    }
    return [];
  });
  return files;
}

type CodeQLLanguageName =
  | "cpp"
  | "csharp"
  | "go"
  | "java"
  | "javascript"
  | "python";

/**
 * Infers the (single) codeql language name that is relevant to use for analysis of `bcve`.
 */
function getCodeqlLanguageName(bcve: BCVE): CodeQLLanguageName[] {
  // Heuristic matching based on extensions.
  // see https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/
  let extensions = new Set(
      bcve.prePatch.weaknesses
        .map(w => w.location)
        .map(l => l.implicitExtension || path.extname(l.file))
    ),
    languages = new Set(
      Array.from(extensions)
        .map(ext => {
          switch (ext) {
            case ".cpp":
            case ".c++":
            case ".cxx":
            case ".hpp":
            case ".hh":
            case ".h++":
            case ".hxx":
            case ".c":
            case ".cc":
            case ".h":
              return "cpp";
            case ".sln":
            case ".csproj":
            case ".cs":
            case ".cshtml":
            case ".xaml":
              return "csharp";
            case ".go":
              return "go";
            case ".java":
              return "java";
            case ".js":
            case ".jsx":
            case ".mjs":
            case ".es":
            case ".es6":
            case ".htm":
            case ".html":
            case ".xhm":
            case ".xhtml":
            case ".vue":
            case ".json":
            case ".yaml":
            case ".yml":
            case ".raml":
            case ".xml":
            case ".ts":
            case ".tsx":
              return "javascript";
            case ".py":
              return "python";
            default:
              return undefined;
          }
        })
        .filter(e => !!e)
    );
  return Array.from(languages);
}

/**
 * Gets the on-disk locations of the queries that are relevant for `bcve`.
 */
function getRelevantQueries(
  bcve: BCVE,
  language: string,
  options: ResolvedDriverOptions
): { language: string; files: File[] } {
  let packs = JSON.parse(
      execFileSyncWithImprovedExceptionMessage(options.codeql, [
        "resolve",
        "qlpacks",
        ...(options.searchPath ? ["--search-path", options.searchPath] : []),
        "--format",
        "json"
      ]).toString()
    ),
    pack: Dir = packs[`codeql-${language}`]?.[0];
  if (pack === undefined) {
    throw new Error(`Could not find qlpack for '${language}'`);
  }
  let files;
  if (options.cveInformation && options.cveInformation[bcve.CVE]) {
    files = options.cveInformation[bcve.CVE].queries.flatMap(queryId =>
      getQueryFileByID(queryId, pack, options.codeql)
    );
  } else {
    files = bcve.CWEs.flatMap(cwe =>
      getQueryFilesByCWENumber(+/CWE-(\d+)/.exec(cwe)[1], pack, options.codeql)
    ).filter(query => {
      let meta = getMetaData(query, options.codeql);
      return (
        !query.includes("/ql/src/experimental/") &&
        ["problem", "path-problem"].includes(meta.kind) &&
        ["medium", "high", "very-high"].includes(meta.precision)
      );
    });
  }
  return {
    language,
    files
  };
}

function analyzeWithDriver(
  options: ResolvedDriverOptions,
  timeout?: number
): Promise<void> {
  async function analyze({
    bcve,
    commitDescription,
    tmp,
    setReproduction,
    setAlerts,
    setStatus,
    getPath
  }: AnalyzeParams) {
    // check if `codeql` works as expected
    execFileSyncWithImprovedExceptionMessage(options.codeql, ["--help"]);

    let languages = getCodeqlLanguageName(bcve);

    if (languages.length === 0) {
      console.warn(`Could not infer codeql language for ${bcve.CVE}`);
      setStatus(BCVEResultStatus.UNSUPPORTED);
      return;
    }
    let language = languages[0];
    if (languages.length > 1) {
      // TODO support multiple languages?
      console.warn(
        `Inferred multiple codeql languages for ${bcve.CVE}: ${Array.from(
          languages
        ).join(", ")}. Choosing to use ${language}.`
      );
    }

    let logdir = path.join(tmp, "logs"),
      queries = getRelevantQueries(bcve, language, options),
      sarifFile: File = path.join(tmp, "results.sarif"),
      databaseDir: Dir = path.join(tmp, "database");

    if (queries.files.length === 0) {
      setStatus(BCVEResultStatus.UNSUPPORTED);
      return;
    }
    fs.mkdirSync(logdir);

    let instructionsOrFailure = selectInstructions(
      bcve.instructions,
      commitDescription.commit,
      language,
      getPath
    );
    if ("failure" in instructionsOrFailure) {
      setStatus(instructionsOrFailure.failure);
      return;
    }
    let instructions = instructionsOrFailure?.instructions;

    let tmpSrcDir = path.join(tmp, "sources");
    fs.copySync(commitDescription.localSourceDirectory, tmpSrcDir);
    let databaseCreateEnv = await setupDatabaseCreateEnvironment(
      instructions,
      language,
      getPath,
      tmpSrcDir,
      tmp
    );
    let commandArgs: string[];
    let command = instructions?.buildCommand;
    if (command && !isInterpretedLanguage(language)) {
      commandArgs = ["--command", command];
    } else {
      commandArgs = [];
    }

    let queryCompileArgs = ["query", "compile", ...queries.files],
      databaseCreateArgs = [
        "database",
        "create",
        "--logdir",
        logdir,
        "--source-root",
        tmpSrcDir,
        ...commandArgs,
        "--language",
        queries.language,
        databaseDir
      ],
      databaseAnalyzeArgs = [
        "database",
        "analyze",
        "--logdir",
        logdir,
        "--format",
        "sarifv2.1.0",
        "--output",
        sarifFile,
        databaseDir,
        ...queries.files
      ];

    let reproduction = [
      `cd ${tmp}`,
      `${options.codeql} ${queryCompileArgs.join(" ")}`,
      `cp -r ${commitDescription.localSourceDirectory} ${tmpSrcDir}`,
      ...(instructions
        ? [
            `# setup environment project-specific environment (${JSON.stringify(
              instructions
            )})`
          ]
        : []),
      `${options.codeql} ${databaseCreateArgs.join(" ")}`,
      `${options.codeql} ${databaseAnalyzeArgs.join(" ")}`
    ].join(" &&\n ");
    setReproduction(reproduction);

    // compile queries ahead of time with a fixed time limit, without influencing the permitted analysis time
    await simpleSpawn(
      options.codeql,
      queryCompileArgs,
      tmp,
      60 * 60 * 1000,
      setStatus
    );

    // analysis
    try {
      await simpleSpawn(
        options.codeql,
        databaseCreateArgs,
        tmp,
        timeout,
        setStatus,
        databaseCreateEnv
      );
    } catch (e) {
      setStatus(BCVEResultStatus.BUILD_FAILURE);
      console.warn(`Failed to create database (got error: ${e})`);
      return;
    }

    await simpleSpawn(
      options.codeql,
      databaseAnalyzeArgs,
      tmp,
      timeout, // TODO the two uses of `timeout` gives the tool twice the timeout time, a manual clock should be maintained here instead.
      setStatus
    );

    let sarif: sarif.Log = readJSONFile(sarifFile);
    setAlerts(
      sarif.runs[0].results.flatMap((r: sarif.Result): BCVEAlert[] =>
        getAlertLocations(r, options.alternatives).map(loc => {
          let file = loc.artifactLocation.uri,
            line = loc.region.startLine,
            location = { file, line };
          return {
            location,
            ruleID: r.ruleId
          };
        })
      )
    );
    setStatus(BCVEResultStatus.SUCCESS);
  }
  return drive(analyze);
}

function getAlertLocations(
  result: sarif.Result,
  alternatives: AlternativeAlertLocationMapping
): sarif.PhysicalLocation[] {
  let alternativesForRule = alternatives[result.ruleId];
  let locations: sarif.PhysicalLocation[] = [];
  if (!alternativesForRule || alternativesForRule.includes(-1)) {
    locations.push(result.locations[0].physicalLocation);
  }
  if (alternativesForRule && result.relatedLocations) {
    locations = result.relatedLocations
      .filter(l => alternativesForRule.includes(l.id))
      .map(l => l.physicalLocation)
      .filter(x => !!x);
  }
  return locations;
}

/**
 * A map from CVE to query ids. Used for forcing the driver to used a
 * specific query for a CVE instead of using heuristics to select the
 * relevant queries.
 */
type CVEInformation = {
  [CVE: string]: {
    queries: RuleID[];
  };
};

/**
 * The options provided in config.json for this driver.
 */
type DriverOptions = {
  /**
   * The codeql binary
   */
  codeql: File;
  /**
   * Controls the qlpack that `codeql` makes use of.
   */
  searchPath?: Dir;

  /**
   * The path to a JSON file that map CVE to query ids. Used for forcing
   * the driver to used a specific query for a CVE instead of using
   * heuristics to select the relevant queries.
   */
  cveInformation?: File;

  /**
   * In the name of presentation, some queries produce alert messages that indirectly links to the weakness location of the benchmark.
   * Depending on the benchmark entry, the primary location of an alert may therefore slightly off.
   *
   * To address this problem, a `(RuleID, LocationIDs)` entry in this map will instead add duplicate alerts with altenative locations for the query with rule id `RuleID`.
   * The alternative locations are the `relatedLocation`s with ids in `LocationIDs`.
   *
   * If the special `LocationID` -1 is used, the original alert location will also be used.
   */
  alternatives?: AlternativeAlertLocationMapping;
};

type ResolvedDriverOptions = {
  codeql: File;
  searchPath?: Dir;
  cveInformation?: CVEInformation;
  alternatives: AlternativeAlertLocationMapping;
};

let defaultAdditionalAlertLocations = {
  "js/shell-command-constructed-from-input": [
    // the `sinkNode.getCommandExecution(), "shell command"` part of the alert message
    3
  ],
  "js/polynomial-redos": [-1, 1]
};
let { toolID, config } = getDriverCommandlineInputs(),
  options: DriverOptions = config.tools[toolID].options,
  resolvedOptions: ResolvedDriverOptions = {
    codeql: options.codeql,
    searchPath: options.searchPath,
    cveInformation: options.cveInformation
      ? readJSONFile(options.cveInformation)
      : undefined,
    alternatives: {
      ...defaultAdditionalAlertLocations,
      ...(options.alternatives || {})
    }
  };
let p = analyzeWithDriver(resolvedOptions, config.tools[toolID].timeout);
p.then(() => process.exit(0)).catch(e => {
  console.error(e);
  process.exit(1);
});

type CompatiableEnvironment = {
  maven?: { version: string; path: string };
  java?: { version: string; path: string };
  python?: { version: string; path: string };
};
type CompatibleInstructions = {
  environment: CompatiableEnvironment;
  buildCommand: string;
};
type CompatibleInstructionsOrFailure =
  | {
      instructions: CompatibleInstructions;
    }
  | {
      failure:
        | BCVEResultStatus.DEPENDENCY_FAILURE
        | BCVEResultStatus.ENVIRONMENT_FAILURE;
    };

function isInterpretedLanguage(language: CodeQLLanguageName): boolean {
  return language === "javascript" || language === "python";
}

function getCompatiableEnvironment(
  env: EnvironmentSpecification,
  getPath: GetPath
): CompatiableEnvironment {
  let compatible = Object.create(null);
  for (let key in env) {
    let path = getPath(key, env[key as keyof EnvironmentSpecification]);
    if (!path) {
      return undefined;
    }
    compatible[key] = path;
  }
  return compatible;
}
function selectInstructions(
  candidateInstructions: Instructions[],
  commit: CommitID,
  language: CodeQLLanguageName,
  getPath: GetPath
): CompatibleInstructionsOrFailure {
  function selectCompatiableInstructions(
    candidateInstructions: Instructions[]
  ): CompatibleInstructionsOrFailure {
    if (!candidateInstructions) {
      return { instructions: undefined };
    }
    candidateInstructions = candidateInstructions.filter(i =>
      i.commits.includes(commit)
    );
    if (candidateInstructions.length == 0) {
      return { instructions: undefined };
    }
    if (candidateInstructions.every(i => i.unsatisfiableDependencies)) {
      console.warn(`Can not build database due to unsatisfiable dependencies`);
      return { failure: BCVEResultStatus.DEPENDENCY_FAILURE };
    }

    candidateInstructions = candidateInstructions.filter(i => {
      let environment = i.environment,
        compatible = getCompatiableEnvironment(environment, getPath);
      if (!compatible) {
        console.warn(
          `Could not satisfy environment requirements for ${JSON.stringify(
            environment
          )}`
        );
      }
      return !!compatible;
    });
    if (candidateInstructions.length === 0) {
      console.warn(
        `Can not build database due to unsupported environment requirements`
      );
      return { failure: BCVEResultStatus.ENVIRONMENT_FAILURE };
    }
    if (candidateInstructions.every(i => i.unsatisfiableDependencies)) {
      console.warn(
        `Can not build database due to unsatisfiable dependencies in supported environments`
      );
      return { failure: BCVEResultStatus.ENVIRONMENT_FAILURE };
    }
    // TODO pick smarter?

    let firstCandidate = candidateInstructions[0];
    return {
      instructions: {
        buildCommand: firstCandidate.buildCommand,
        environment: getCompatiableEnvironment(
          firstCandidate.environment,
          getPath
        )
      }
    };
  }
  let compatible: CompatibleInstructionsOrFailure;
  if (!isInterpretedLanguage(language) || language === "python") {
    compatible = selectCompatiableInstructions(candidateInstructions);
  } else {
    compatible = { instructions: undefined };
  }
  return compatible;
}

async function setupDatabaseCreateEnvironment(
  instructions: CompatibleInstructions,
  language: CodeQLLanguageName,
  getPath: GetPath,
  workdir: Dir,
  tmpDir: Dir
): Promise<Record<string, string>> {
  async function pipInstall() {
    let compatiblePython = instructions?.environment?.python;
    env["LGTM_PYTHON_SETUP_VERSION"] = compatiblePython?.version;

    let python = "python";
    if (compatiblePython?.path) {
      python = getPath("python", compatiblePython.path);
    }

    let fullVersion = await new Promise<string>((resolve, reject) => {
        cp.execFile(python, ["--version"], (err, _stdout, stderr) => {
          if (err) {
            console.error(stderr);
            reject(err);
          }
          resolve(stderr.toString().trim());
        });
      }),
      versionMatch = /^Python (\d+).*/.exec(fullVersion),
      majorVersion = versionMatch && versionMatch[1],
      vEnvDir = path.join(tmpDir, "venv");
    switch (majorVersion) {
      case "2":
        cp.execFileSync(python, ["-m", "virtualenv", vEnvDir]);
        break;
      case "3":
        cp.execFileSync(python, ["-m", "venv", vEnvDir]);
        break;
      default:
        throw new Error(`Unsupported Python version: ${majorVersion}`);
    }
    let vEnvPip = path.join(vEnvDir, "bin", "pip");

    cp.execFileSync(vEnvPip, ["install", workdir]);
  }
  function getPathAdditions() {
    let pathAdditions = [],
      executableAdditions: Record<string, File> = {};
    if (language === "java") {
      let javaPath = instructions?.environment?.java?.path;
      if (javaPath) {
        pathAdditions.push(path.join(javaPath, "bin"));
      }
      let mavenPath = instructions?.environment?.maven?.path;
      if (mavenPath) {
        executableAdditions.mvn = mavenPath;
      }
    }
    let customExecutablesOnPath = path.join(tmpDir, "custom-executables");
    if (Object.keys(executableAdditions).length) {
      fs.mkdirSync(customExecutablesOnPath);
      pathAdditions.unshift(customExecutablesOnPath);
      Object.entries(executableAdditions).forEach(([k, v]) => {
        fs.symlinkSync(v, path.join(customExecutablesOnPath, k));
      });
    }
    return pathAdditions;
  }

  let env: Record<string, string> = { ...process.env };
  let pathAdditions = getPathAdditions();
  if (pathAdditions.length > 0) {
    env.PATH = `${pathAdditions.join(path.delimiter)}${path.delimiter}${
      process.env.PATH
    }`;
  }
  if (language === "python") {
    await pipInstall();
  }
  return env;
}
