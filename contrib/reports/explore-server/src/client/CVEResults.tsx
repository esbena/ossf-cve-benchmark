import * as React from "react";
import CVEResultSummarization from "./CVEResultSummarization";
import * as MyCodeMirrors from "./MyCodeMirrors";
import { Alert, CommitData, Weakness } from "../shared/shared-types";
import { Server } from "./ServerFacade";

function byLineSorter<T extends Weakness | Alert>(a1: T, a2: T) {
  // this line-sorting is apparently important for CodeMirror performance
  let cmp = a1.line - a2.line;
  if (cmp !== 0) {
    return cmp;
  }
  let ruleCompare = (a1 as Alert).ruleID?.localeCompare?.((a2 as Alert).ruleID);
  return (
    ruleCompare ??
    (a1 as Weakness).explanation?.localeCompare?.(
      (a2 as Weakness).explanation
    ) ??
    0
  );
}
async function getSortedAlerts(cve: string, server: Server): Promise<Alert[]> {
  return (await server.getAlerts(cve)).sort(byLineSorter);
}
async function getSortedWeaknesses(cve: string, server: Server) {
  return (await server.getWeaknesses(cve)).sort(byLineSorter);
}

// TODO reformulate data entirely? Rely on the stable BCVE type instead?
type Props = {
  CVE: string;
  toolIDs: string[];
  toolRuns: { [toolID: string]: string[] };
  CWEs: string[];
  server: Server;
};
type State = {
  source?: string;
  commit?: CommitData;
  file?: string;
  line?: number;
  alerts: Alert[];
  weaknesses: Weakness[];
  unpatchedCommit?: CommitData;
  patchCommit?: CommitData;
  repository?: string;
};

export class CVEResults extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { alerts: [], weaknesses: [] };
  }
  async componentDidMount() {
    let server = this.props.server;
    let weaknesses = await getSortedWeaknesses(this.props.CVE, server),
      { patchCommit, unpatchedCommit } = await server.getCVECommits(
        this.props.CVE
      ),
      repository = await server.getCVERepository(this.props.CVE),
      selection = weaknesses[0],
      alerts = await getSortedAlerts(this.props.CVE, server),
      source =
        selection &&
        (await getFileSource(selection.commit, selection.file, server));

    this.setState({
      alerts,
      weaknesses,
      file: selection?.file,
      line: selection?.line,
      source,
      commit: selection?.commit,
      patchCommit: patchCommit,
      unpatchedCommit: unpatchedCommit,
      repository: repository
    });
  }
  render() {
    if (this.state.unpatchedCommit === undefined) {
      return null; // XXX not yet mounted
    }
    let self = this;
    function setSourceFocus(o: {
      source: string;
      line: number;
      file: string;
      commit: CommitData;
    }) {
      self.setState(o);
    }

    function isRelevant(a: Weakness & Alert) {
      return (
        a.file === self.state.file &&
        a.commit.commitID === self.state.commit.commitID
      );
    }
    return (
      <div>
        <h2>{self.props.CVE}</h2>
        <h3>
          <a href={self.state.repository}>
            {extractRepoSlug(self.state.repository)}
          </a>
        </h3>
        <CVEResultSummarization
          CVE={self.props.CVE}
          toolIDs={self.props.toolIDs}
          setSourceFocus={setSourceFocus}
          alerts={self.state.alerts}
          weaknesses={self.state.weaknesses}
          patchCommit={self.state.patchCommit}
          unpatchedCommit={self.state.unpatchedCommit}
          toolRuns={self.props.toolRuns}
          CWEs={this.props.CWEs}
          server={this.props.server}
        />{" "}
        <hr />
        <h2 className="source-code">Source code</h2>
        <MyCodeMirrors.default.AnnotatedCodeMirror
          toolIDs={self.props.toolIDs}
          source={self.state.source}
          file={self.state.file}
          fileUrl={getFileBrowseUrl(self.state.commit, self.state.file)}
          line={self.state.line}
          gutterAnnotations={self.state.alerts.filter(isRelevant)}
          lineAnnotations={self.state.weaknesses.filter(isRelevant)}
        />
      </div>
    );
  }
}
function extractRepoSlug(repository: string) {
  let githubRepoPattern = /^https:\/\/github.com\/([^/]+)\/([^/]+)\.git$/;
  let github = repository.match(githubRepoPattern);
  if (github) {
    let [, owner, repo] = github;
    return `${owner}/${repo}`;
  }
  return undefined; // TODO support non-github.com URLs
}

let githubCommitPattern = /^https:\/\/github.com\/([^/]+\/[^/]+)\/commit\/([a-f0-9]+)$/;
function getFileBrowseUrl(commit: CommitData, file: string): string {
  if (commit.permalink) {
    let github = commit.permalink.match(githubCommitPattern);
    if (github) {
      return `${github[1]}/blob/${github[2]}/${file}`;
    }
  }
  return undefined; // TODO support non-github.com URLs
}

async function getFileSource(commit: CommitData, file: string, server: Server) {
  let sourceGetters: (() => Promise<string>)[] = [];
  // prefer local sources
  sourceGetters.push(() =>
    server.getOptionalSource(commit.CVE, commit.commitID, file)
  );
  // then try hosted sources
  if (commit.permalink) {
    let github = commit.permalink.match(githubCommitPattern);
    if (github) {
      sourceGetters.push(
        async () =>
          await (
            await fetch(
              // XXX rate limited to 60/hour!
              `https://raw.githubusercontent.com/${github[1]}/${github[2]}/${file}`
            )
          ).text()
      );
    }
  }

  for await (let sourceGetter of sourceGetters) {
    let source = await sourceGetter();
    if (source) {
      return source;
    }
  }
  return undefined;
}
