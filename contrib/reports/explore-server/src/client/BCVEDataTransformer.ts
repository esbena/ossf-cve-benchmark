import {
  File,
  BCVE,
  CVEString,
  CommitID,
  CommitDescription,
  ToolID,
  RuleID,
  CWEString
} from "../../../../../src/persistent-types";
import * as ClientTypes from "../shared/shared-types";
function makePermalink(repository: string, commit: CommitID) {
  let githubRepoPattern = /^https:\/\/github.com\/([^/]+)\/([^/]+)\.git$/;
  let github = repository.match(githubRepoPattern);
  if (github) {
    let [, owner, repo] = github;
    return `https://github.com/${owner}/${repo}/commit/${commit}`;
  }
  return undefined; // TODO support non-github.com URLs
}
function makeCommitData(
  cve: CVEString,
  repository: string,
  commit: CommitDescription
): ClientTypes.CommitData {
  return {
    CVE: cve,
    commitID: commit.commit,
    permalink: makePermalink(repository, commit.commit)
  };
}
function buildTargetsMap(bcves: BCVE[]): TargetsMap {
  let weaknessLocations = bcves
    .flatMap(bcve =>
      [bcve.prePatch, bcve.postPatch].map(c => ({
        CVE: bcve.CVE,
        commit: c.commit,
        weaknesses: c.weaknesses
      }))
    )
    .flatMap(g =>
      (g.weaknesses || [])
        .filter(w => !!w.location)
        .map(w => ({
          CVE: g.CVE,
          commit: g.commit,
          file: w.location.file,
          line: w.location.line
        }))
    );
  let targets = new Map();
  weaknessLocations.forEach(l => {
    if (!targets.has(l.CVE)) {
      targets.set(l.CVE, new Map());
    }

    let byCVE = targets.get(l.CVE);
    if (!byCVE.has(l.commit)) {
      byCVE.set(l.commit, new Map());
    }

    let byCVEAndCommit = byCVE.get(l.commit);
    if (!byCVEAndCommit.has(l.file)) {
      byCVEAndCommit.set(l.file, new Set());
    }

    let byCVEAndCommitAndFile = byCVEAndCommit.get(l.file);
    byCVEAndCommitAndFile.add(l.line);
  });
  return targets;
}

function buildRulesOnATargetMap(
  bcves: BCVE[],
  targets: TargetsMap
): RulesOnTargetMap {
  let unmapped = bcves.flatMap(bcve =>
    (bcve.prePatch.runs || []).flatMap(r =>
      (r.alerts || [])
        .filter(
          a =>
            a.location &&
            isOnTarget(
              bcve.CVE,
              bcve.prePatch.commit,
              a.location.file,
              a.location.line,
              targets
            )
        )
        .map(a => ({
          CVE: bcve.CVE,
          toolID: r.toolID,
          ruleID: a.ruleID
        }))
    )
  );
  let rulesOnATarget = new Map();
  unmapped.forEach(u => {
    if (!rulesOnATarget.has(u.CVE)) {
      rulesOnATarget.set(u.CVE, new Map());
    }

    let byCVE = rulesOnATarget.get(u.CVE);
    if (!byCVE.has(u.toolID)) {
      byCVE.set(u.toolID, new Set());
    }

    let byCVEAndToolID = byCVE.get(u.toolID);
    byCVEAndToolID.add(u.ruleID);
  });
  return rulesOnATarget;
}

function isOnTarget(
  cve: CVEString,
  commit: CommitID,
  file: File,
  line: number,
  targets: TargetsMap
): boolean {
  return !!targets.get(cve)?.get(commit)?.get(file)?.has(line);
}

function isForRuleOnATarget(
  cve: CVEString,
  toolID: ToolID,
  ruleID: RuleID,
  rulesOnATarget: RulesOnTargetMap
): boolean {
  return !!rulesOnATarget.get(cve)?.get(toolID)?.has(ruleID);
}

type TargetsMap = Map<CVEString, Map<CommitID, Map<File, Set<number>>>>;
type RulesOnTargetMap = Map<CVEString, Map<ToolID, Set<RuleID>>>;
export class Transformer {
  private targets: TargetsMap = new Map();
  private rulesOnATarget: RulesOnTargetMap = new Map();
  constructor(private bcves: BCVE[]) {
    this.targets = buildTargetsMap(bcves);
    this.rulesOnATarget = buildRulesOnATargetMap(bcves, this.targets);
  }

  private getBCVE(cve: CVEString) {
    return this.bcves.find(bcve => bcve.CVE === cve);
  }

  private getAlertsForBCVE(bcve: BCVE): ClientTypes.Alert[] {
    let targets = this.targets,
      rulesOnATarget = this.rulesOnATarget;

    function getAlerts(
      commitDescription: CommitDescription
    ): ClientTypes.Alert[] {
      let alerts = (commitDescription.runs || []).flatMap(r =>
        (r.alerts || [])
          .filter(a => !!a.location)
          .map(a => ({
            CVE: bcve.CVE,
            commit: makeCommitData(
              bcve.CVE,
              bcve.repository,
              commitDescription
            ),
            file: a.location.file,
            line: a.location.line,
            toolID: r.toolID,
            ruleID: a.ruleID,
            isOnTarget: isOnTarget(
              bcve.CVE,
              commitDescription.commit,
              a.location.file,
              a.location.line,
              targets
            ),
            isForRuleOnATarget: isForRuleOnATarget(
              bcve.CVE,
              r.toolID,
              a.ruleID,
              rulesOnATarget
            ),
            url: a.url
          }))
      );
      return alerts;
    }
    let alerts = [];
    if (bcve.prePatch) {
      alerts.push(...getAlerts(bcve.prePatch));
    }
    if (bcve.postPatch) {
      alerts.push(...getAlerts(bcve.postPatch));
    }
    return alerts;
  }
  private getWeaknesses(): { [cve: string]: ClientTypes.Weakness[] } {
    function getWeaknesses(
      cve: CVEString,
      repository: string,
      commitDescription: CommitDescription
    ): ClientTypes.Weakness[] {
      let weaknesses = (commitDescription.weaknesses || [])
        .filter(w => w.location)
        .map(w => ({
          CVE: cve,
          commit: makeCommitData(cve, repository, commitDescription),
          file: w.location.file,
          line: w.location.line,
          explanation: w.explanation
        }));
      return weaknesses;
    }

    let mapped: { [cve: string]: ClientTypes.Weakness[] } = {};
    this.bcves.forEach(bcve => {
      let weaknesses = [];
      if (bcve.prePatch) {
        weaknesses.push(
          ...getWeaknesses(bcve.CVE, bcve.repository, bcve.prePatch)
        );
      }
      if (bcve.postPatch) {
        weaknesses.push(
          ...getWeaknesses(bcve.CVE, bcve.repository, bcve.postPatch)
        );
      }
      mapped[bcve.CVE] = weaknesses;
    });
    return mapped;
  }

  public getToolIds() {
    return Array.from(
      new Set(
        this.bcves.flatMap(bcve =>
          [bcve.prePatch, bcve.postPatch].flatMap(c =>
            (c.runs || []).map(r => r.toolID)
          )
        )
      )
    );
  }

  public getAllToolRuns() {
    return this.bcves.flatMap(bcve =>
      [bcve.prePatch, bcve.postPatch].flatMap(c =>
        (c.runs || []).map(r => ({
          CVE: bcve.CVE,
          toolID: r.toolID,
          commit: c.commit
        }))
      )
    );
  }

  public getCVE2CWEs() {
    let map: { [cve: string]: CWEString[] } = {};
    this.bcves.forEach(bcve => (map[bcve.CVE] = bcve.CWEs));
    return map;
  }

  public getCVEs() {
    return this.bcves.map(bcve => bcve.CVE);
  }

  public getAlerts(cve: CVEString): ClientTypes.Alert[] {
    let bcve = this.getBCVE(cve);
    if (!bcve) {
      console.warn(`No BCVE for ${cve}`);
      return [];
    }
    return this.getAlertsForBCVE(bcve);
  }

  public getCVEWeaknesses(cve: CVEString): ClientTypes.Weakness[] {
    function getWeaknesses(
      kind: "prePatch" | "postPatch",
      commitDescription: CommitDescription
    ): ClientTypes.Weakness[] {
      let weaknesses = (commitDescription.weaknesses || [])
        .filter(w => !!w.location)
        .map(w => ({
          CVE: cve,
          commitKind: kind,
          commit: makeCommitData(bcve.CVE, bcve.repository, commitDescription),
          file: w.location.file,
          line: w.location.line,
          explanation: w.explanation
        }));
      return weaknesses;
    }
    let bcve = this.getBCVE(cve);
    if (!bcve) {
      console.warn(`No BCVE for ${cve}`);
      return [];
    }
    let weaknesses = [];
    if (bcve.prePatch) {
      weaknesses.push(...getWeaknesses("prePatch", bcve.prePatch));
    }
    if (bcve.postPatch) {
      weaknesses.push(...getWeaknesses("postPatch", bcve.postPatch));
    }
    return weaknesses;
  }

  public getCommits() {
    return this.bcves.flatMap(bcve => {
      let commits: ClientTypes.CommitData[] = [];
      if (bcve.prePatch) {
        commits.push(makeCommitData(bcve.CVE, bcve.repository, bcve.prePatch));
      }
      if (bcve.postPatch) {
        commits.push(makeCommitData(bcve.CVE, bcve.repository, bcve.postPatch));
      }
      return commits;
    });
  }

  public getCVECommits(cve: CVEString) {
    let bcve = this.getBCVE(cve);
    return {
      unpatchedCommit: makeCommitData(bcve.CVE, bcve.repository, bcve.prePatch),
      patchCommit: makeCommitData(bcve.CVE, bcve.repository, bcve.postPatch)
    };
  }

  public getCVERepository(cve: CVEString) {
    return this.getBCVE(cve).repository;
  }

  public getAllCVECommits() {
    return this.bcves.map(bcve => ({
      unpatchedCommit: makeCommitData(bcve.CVE, bcve.repository, bcve.prePatch),
      patchCommit: makeCommitData(bcve.CVE, bcve.repository, bcve.postPatch)
    }));
  }

  public getAllAlerts() {
    return this.bcves.flatMap(bcve => this.getAlertsForBCVE(bcve));
  }

  public getAllWeaknesses() {
    return Object.values(this.getWeaknesses()).flatMap(id => id);
  }
}
