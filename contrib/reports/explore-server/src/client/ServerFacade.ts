/**
 * Implements the client-side view of a remote server.
 */

import { Alert, CommitData, Weakness } from "../shared/shared-types";
import { BCVE } from "../../../../../src/persistent-types";
import * as util from "./util";
import { Transformer } from "./BCVEDataTransformer";
import { getAllCWENames } from "./CWENames";

// XXX strengthen these types
type ToolId = string;
type ToolRun = any;
type CVE = string;
type CWE = string;
type CVE2CWEMap = Record<CVE, CWE[]>;
type CVECommits = { patchCommit: CommitData; unpatchedCommit: CommitData };
type Repository = string;
type CommitId = string;
type File = string;

async function json(
  url: string,
  cache: Map<string, any>
): Promise<Promise<{ json: any; status: number }>> {
  if (!cache.has(url)) {
    let response = await fetch(url);
    let json = await response.json();
    cache.set(url, { json: json, status: response.status });
  }
  return cache.get(url);
}
async function text(
  url: string,
  cache: Map<string, any>
): Promise<{ text: string; status: number }> {
  if (!cache.has(url)) {
    let response = await fetch(url);
    let text = await response.text();
    cache.set(url, { text: text, status: response.status });
  }
  return cache.get(url);
}
export interface Server {
  getAlerts(cve: CVE): Promise<Alert[]>;
  getAllAlerts(): Promise<Alert[]>;
  getAllCVECommits(): Promise<CVECommits[]>;
  getAllToolRuns(): Promise<ToolRun[]>;
  getAllWeaknesses(): Promise<Weakness[]>;
  getCVE2CWEs(): Promise<CVE2CWEMap>;
  getCVECommits(cve: CVE): Promise<CVECommits>;
  getCVERepository(cve: CVE): Promise<Repository>;
  getCVEs(): Promise<CVE[]>;
  getCWENames(): Promise<Record<CWE, string>>;
  getBenchmarkSource(cve: CVE): Promise<string>;
  getOptionalSource(cve: CVE, commitId: CommitId, file: File): Promise<string>;
  getToolIds(): Promise<ToolId[]>;
  getCVEWeaknesses(cve: CVE): Promise<Weakness[]>;
}

/**
 * Communicates with a static remote server that only supports simple file path GET requests.
 *
 * (currently uses as dynamic server as fallback for GET requests with parameters)
 */
export class StaticServer implements Server {
  private cache = new Map<string, any>();
  private transformer: Transformer;
  constructor(private bcves: BCVE[], bcvesWithRuns: BCVE[]) {
    this.transformer = new Transformer(bcvesWithRuns);
  }
  async json(path: string) {
    return (await json(util.mkSimpleURL(path), this.cache)).json;
  }
  async text(path: string) {
    return (await text(util.mkSimpleURL(path), this.cache)).text;
  }

  getToolIds() {
    return Promise.resolve(this.transformer.getToolIds());
  }
  getAllToolRuns() {
    return Promise.resolve(this.transformer.getAllToolRuns());
  }
  getCVE2CWEs() {
    return Promise.resolve(this.transformer.getCVE2CWEs());
  }
  getCVEs() {
    return Promise.resolve(this.transformer.getCVEs());
  }
  getAlerts(cve: CVE) {
    return Promise.resolve(this.transformer.getAlerts(cve));
  }
  getCVEWeaknesses(cve: CVE) {
    return Promise.resolve(this.transformer.getCVEWeaknesses(cve));
  }
  getCVECommits(cve: CVE) {
    return Promise.resolve(this.transformer.getCVECommits(cve));
  }
  getCVERepository(cve: CVE) {
    return Promise.resolve(this.transformer.getCVERepository(cve));
  }
  async getOptionalSource(_cve: CVE, _commit: CommitId, _file: File) {
    // TODO support sources
    return Promise.resolve(undefined);
  }

  getAllCVECommits() {
    return Promise.resolve(this.transformer.getAllCVECommits());
  }

  getAllAlerts() {
    return Promise.resolve(this.transformer.getAllAlerts());
  }
  getAllWeaknesses() {
    return Promise.resolve(this.transformer.getAllWeaknesses());
  }
  getCWENames() {
    return getAllCWENames();
  }
  async getBenchmarkSource(cve: CVE) {
    return Promise.resolve(
      JSON.stringify(
        this.bcves.find(bcve => bcve.CVE === cve),
        null,
        2
      )
    );
  }
}

/**
 * Communicates with a dynamic remote server that supports GET parameters.
 */
export class DynamicServer implements Server {
  private cache = new Map<string, any>();

  async json(path: string, params?: Record<string, string | number | boolean>) {
    return (await json(util.mkSimpleURL(path, params), this.cache)).json;
  }
  async text(path: string, params: Record<string, string | number | boolean>) {
    return (await text(util.mkSimpleURL(path, params), this.cache)).text;
  }

  getToolIds() {
    return this.json("/data/getToolIds");
  }
  getAllToolRuns() {
    return this.json("/data/getAllToolRuns");
  }
  getCVE2CWEs() {
    return this.json("/data/getCVE2CWEs");
  }
  getCVEs() {
    return this.json("/data/getCVEs");
  }
  getAlerts(cve: CVE) {
    return this.json("/data/getAlerts", {
      CVE: cve
    });
  }
  getCVEWeaknesses(cve: CVE) {
    return this.json("/data/getCVEWeaknesses", {
      CVE: cve
    });
  }
  getCVECommits(cve: CVE) {
    return this.json("/data/getCVECommits", { CVE: cve });
  }
  getCVERepository(cve: CVE) {
    return this.text("/data/getCVERepository", {
      CVE: cve
    });
  }
  async getOptionalSource(cve: CVE, commit: CommitId, file: File) {
    let response = await text(
      util.mkSimpleURL("/data/sources", {
        CVE: cve,
        commit: commit,
        file: file
      }),
      this.cache
    );
    if (response.status === 200) {
      return response.text;
    }
    return undefined;
  }

  getAllCVECommits() {
    return this.json("/data/getAllCVECommits");
  }

  getAllAlerts() {
    return this.json("/data/getAllAlerts");
  }
  getAllWeaknesses() {
    return this.json("/data/getAllWeaknesses");
  }
  getCWENames() {
    return getAllCWENames();
  }
  async getBenchmarkSource(cve: CVE) {
    let response = await text(
      util.mkSimpleURL("/data/getBenchmarkSource", {
        CVE: cve
      }),
      this.cache
    );
    if (response.status === 200) {
      return response.text;
    }
    return undefined;
  }
}
