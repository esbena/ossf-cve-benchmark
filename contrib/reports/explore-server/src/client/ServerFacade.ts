/**
 * Implements the client-side view of a remote server.
 */

import { Alert, CommitData, Weakness } from "../shared/shared-types";
import * as util from "./util";

// XXX strengthen these types
type ToolId = string;
type ToolRun = any;
type CVE = string;
type CWE = string;
type CVE2CWEMap = Record<CVE, CWE[]>;
type CVECommits = { patchCommit: CommitData; unpatchedCommit: CommitData };
type Repository = string;
type CommitId = string;
type File = string;

async function json(
  url: string,
  cache: Map<string, any>
): Promise<Promise<{ json: any; status: number }>> {
  if (!cache.has(url)) {
    let response = await fetch(url);
    let json = await response.json();
    cache.set(url, { json: json, status: response.status });
  }
  return cache.get(url);
}
async function text(
  url: string,
  cache: Map<string, any>
): Promise<{ text: string; status: number }> {
  if (!cache.has(url)) {
    let response = await fetch(url);
    let text = await response.text();
    cache.set(url, { text: text, status: response.status });
  }
  return cache.get(url);
}
export interface Server {
  getAlerts(cve: CVE): Promise<Alert[]>;
  getAllAlerts(): Promise<Alert[]>;
  getAllCVECommits(): Promise<CVECommits[]>;
  getAllToolRuns(): Promise<ToolRun[]>;
  getAllWeaknesses(): Promise<Weakness[]>;
  getCVE2CWEs(): Promise<CVE2CWEMap>;
  getCVECommits(cve: CVE): Promise<CVECommits>;
  getCVERepository(cve: CVE): Promise<Repository>;
  getCVEs(): Promise<CVE[]>;
  getCWENames(): Promise<Record<CWE, string>>;
  getOptionalBenchmarkSource(cve: CVE): Promise<string>;
  getOptionalSource(cve: CVE, commitId: CommitId, file: File): Promise<string>;
  getToolIds(): Promise<ToolId[]>;
  getWeaknesses(cve: CVE): Promise<Weakness[]>;
}

/**
 * Communicates with a static remote server that only supports simple file path GET requests.
 *
 * (currently uses as dynamic server as fallback for GET requests with parameters)
 */
export class StaticServer implements Server {
  private cache = new Map<string, any>();
  private dynamic = new DynamicServer();

  async json(path: string) {
    return (await json(util.mkSimpleURL(path), this.cache)).json;
  }
  async text(path: string) {
    return (await text(util.mkSimpleURL(path), this.cache)).text;
  }

  getToolIds() {
    return this.json("/data/getToolIds");
  }
  getAllToolRuns() {
    return this.json("/data/getAllToolRuns");
  }
  getCVE2CWEs() {
    return this.json("/data/getCVE2CWEs");
  }
  getCVEs() {
    return this.json("/data/getCVEs");
  }
  getAlerts(cve: CVE) {
    return this.dynamic.getAlerts(cve);
  }
  getWeaknesses(cve: CVE) {
    return this.dynamic.getWeaknesses(cve);
  }
  getCVECommits(cve: CVE) {
    return this.dynamic.getCVECommits(cve);
  }
  getCVERepository(cve: CVE) {
    return this.dynamic.getCVERepository(cve);
  }
  async getOptionalSource(cve: CVE, commit: CommitId, file: File) {
    let response = await text(
      util.mkSimpleURL("/data/sources", {
        CVE: cve,
        commit: commit,
        file: file
      }),
      this.cache
    );
    if (response.status === 200) {
      return response.text;
    }
    return undefined;
  }

  getAllCVECommits() {
    return this.json("/data/getAllCVECommits");
  }

  getAllAlerts() {
    return this.json("/data/getAllAlerts");
  }
  getAllWeaknesses() {
    return this.json("/data/getAllWeaknesses");
  }
  getCWENames() {
    return this.json("/data/getCWENames");
  }
  async getOptionalBenchmarkSource(cve: CVE) {
    let response = await text(
      util.mkSimpleURL("/data/getBenchmarkSource", {
        CVE: cve
      }),
      this.cache
    );
    if (response.status === 200) {
      return response.text;
    }
    return undefined;
  }
}

/**
 * Communicates with a dynamic remote server that supports GET parameters.
 */
export class DynamicServer implements Server {
  private cache = new Map<string, any>();

  async json(path: string, params?: Record<string, string | number | boolean>) {
    return (await json(util.mkSimpleURL(path, params), this.cache)).json;
  }
  async text(path: string, params: Record<string, string | number | boolean>) {
    return (await text(util.mkSimpleURL(path, params), this.cache)).text;
  }

  getToolIds() {
    return this.json("/data/getToolIds");
  }
  getAllToolRuns() {
    return this.json("/data/getAllToolRuns");
  }
  getCVE2CWEs() {
    return this.json("/data/getCVE2CWEs");
  }
  getCVEs() {
    return this.json("/data/getCVEs");
  }
  getAlerts(cve: CVE) {
    return this.json("/data/getAlerts", {
      CVE: cve
    });
  }
  getWeaknesses(cve: CVE) {
    return this.json("/data/getCVEWeaknesses", {
      CVE: cve
    });
  }
  getCVECommits(cve: CVE) {
    return this.json("/data/getCVECommits", { CVE: cve });
  }
  getCVERepository(cve: CVE) {
    return this.text("/data/getCVERepository", {
      CVE: cve
    });
  }
  async getOptionalSource(cve: CVE, commit: CommitId, file: File) {
    let response = await text(
      util.mkSimpleURL("/data/sources", {
        CVE: cve,
        commit: commit,
        file: file
      }),
      this.cache
    );
    if (response.status === 200) {
      return response.text;
    }
    return undefined;
  }

  getAllCVECommits() {
    return this.json("/data/getAllCVECommits");
  }

  getAllAlerts() {
    return this.json("/data/getAllAlerts");
  }
  getAllWeaknesses() {
    return this.json("/data/getAllWeaknesses");
  }
  getCWENames() {
    return this.json("/data/getCWENames");
  }
  async getOptionalBenchmarkSource(cve: CVE) {
    let response = await text(
      util.mkSimpleURL("/data/getBenchmarkSource", {
        CVE: cve
      }),
      this.cache
    );
    if (response.status === 200) {
      return response.text;
    }
    return undefined;
  }
}
